# C9. Interview

한 회사가 새로운 소프트웨어 개발자들을 고용하고 있다. N명의 지원자들을 위해 문서 리뷰와 프로그래밍 테스트가 이미 수행되었다. 그리고 한 지원자의 점수 P는 두 개의 양의 정수들의 쌍으로 결정된다. x는 review 점수이고, y는 프로그래밍 테스트 점수이다.

그들의 취업 면접을 준비하기 위해, 당신은 다음 규칙에 따라 N명의 지원자들을 그룹화해야 한다.

1. 두 지원자 Pi와 Pj는 같은 그룹에 속해져야 한다. 만약 xi < xy 이면서 yi > yj 일 때, 혹은 xi > xy 이면서 yi < yj.
2. 그룹은 가능한 많이 만들어져야 한다.

가능한 가장 많은 지원자 그룹을 결정하는 프로그램을 정해라.

-----

### Input

- Input은 standard input으로 주어진다.
- 첫 줄은 1이상 8000이하의 하나의 정수이다.
- 다음 줄부터는 두 정수 x, y를 입력받는데, 0<=x<=1,000,000 이고 0<=y<1,000,000 이다.

### Ouput

- 가장 최대로 많이 짝지어지는 interview group을 출력해라.

----

아예 나뉘어져야 하는지? 

8 6
14 12
15 6
20 10

첫 input 부터 입력받으면서

x, y가 모두 크면 새로운 그룹에 넣기. 넣을 때마다 그 그룹의 x y가 바뀐다. x는 최대값, y는 

정렬해놓은 상태면, 무조건 x를 크다. 그렇기 때문에 y가 더 큰지만 판단하면 된다. 이전 그룹들의 y가 더 크면 

------

8 9
14 12
15 16
20 10

이라고 하면, 한 그룹이 됨. 그리고 이전의 모든 항목들을 다 검사해야 함.

그래서 생각은,

이전 사람들의 y값의 최소값을 정해놓고 

---

저는 brute force긴 한데, 이전의 모든 인덱스를 훑는 것이 아니라, 이전에 생성된 그룹들을 훑는 방식을 생각해봤어요.

이제 그룹을 생성할 때에는, 두 사람이 합쳐질 텐데, 그때 x의 최대값, y의 최소값이 그 그룹의 점수가 되는 방식으로요.

예를 들어서
8 9
14 12 
15 6 
20 10
라고 했을 때에, 1번과 3번은 그룹이 되겠죠?
그룹 1 - 8 19
그룹 2 - 14 12
까지 구성된다음에, 15,6번째 애가 들어오게 되면
두 그룹을 검사를 하는거죠.

그러면 그룹화될 때 15, 9가 될텐데, 

---------

##### 맨 처음 방법(미완) : 

1. input을 (x,y)로 입력받고, x값으로 오름차순 정렬시킨다.
2. 전체 사람 수를 person이라고 할 때 person 만큼 for문을 돌리는데, x가 낮은 pair부터 돌린다.
3. 초기 그룹은 (0,1000000)하나가 있다고 가정한다. 그러면 처음 값은 무조건 그룹에 속하게 되기 때문이다.
4. 그룹에 속하는지 확인하는 것은, 그룹의 개수(group) 만큼 for문을 돌리는데, 그룹의 최대 x값(max_x), 최대 y(max_y)값과 비교하면 된다. 현재 x, y값과 최대 x, y값이 있다고 할 때, 현 x는 최대 x보다 무조건 크거나 같기 때문에, 현 y값이 최대 y값보다 작거나 같은지만 비교하면 된다. 만약 작거나 같다면 그룹에 속하게 되고, x값을 최신화 시켜주면 된다. 

------

##### 다른 방법 : 

1. input을 (x,y)로 입력받고, x값으로 오름차순 정렬시킨다.
2. 전체 사람 수를 person이라고 할 때 person 만큼 for문을 돌리는데, x가 낮은 pair부터 돌린다.
3. for 문 안에 for문으로 두번 돌리지만, 이미 한 요소는 다른 요소와 체크가 되었기 때문에 더이상 살펴보지 않는다. (모든 요소와 검사가 되었기 때문에 나중에 확인할 필요가 없다.)
   예를 들어, 아래처럼 총 7쌍이 있다고 할 때,
   0 : (8,9)
   1 : (14,12)
   2 : (15,6)
   3 : (20,10)
   4 : (25,19)
   5 : (30,15)
   6 : (35,10) 
   (8,9) 입장에서 아래 7개 요소와 그룹이 가능한지를 체크한다.
   그다음에는 (14,12) 입장에서 아래 6개 요소와 그룹이 가능한지를 체크한다.
   그다음에는 (15, 6) 입장에서 아래 5개 요소와 그룹이 가능한지를 체크한다.
4. 위와 같이 요소와 요소를 검사할 때에는 (x좌표, y좌표) 조건에 부합하는지를 체크하는 것. 정렬이 되어있기 때문에 y좌표가 작은지만 검사하면 될 것이다.
   만약 서로 같은 그룹이 된다면 인접 리스트에 값을 추가한다. (ex. 1이 2와 같은 그룹이면 1-2, 2-1과 같은 방식으로)
   이 방식은 n^2보다 무조건 적다. 왜냐하면 이미 검사한 부분에 대해서는 검사하지 않기 때문이다.
   n-1, n-2, n-3, n-4, n-5, n-6 ......... 2, 1 까지 검사하기 때문에 n만큼 n번 검사하는 n^2보다는 훨씬 적게 걸린다.
5. 이렇게 인접 리스트가 나오게 되면, connected component인지를 확인해야 한다. (그래프에서 섬 개수찾기)
   예를 들어서
   1 - 2, 3, 4
   2 - 1
   3 - 1
   4 - 1
   5 - 6
   6 - 5
   7 -
   8 -
   과 같이 나오게 된다면  Connected component는 (1,2,3,4) (5,6) (7) (8) 이 나오게 되기 때문에 4그룹이 답이 되는 것이다. 이것은 인접 리스트를 구한 뒤에 DFS를 통해 개수를 찾아낼 수 있다. 

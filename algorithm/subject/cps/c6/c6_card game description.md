# C6. Card Game.

혼자 1부터 최대, 50000개의 카드로 카드 게임을 한다. 각 카드는 정수를 가지고, 1에서 10의 9승까지의 숫자를 가진다. 

게임에서, 딜러는 플레이어들에게 n개의 카드를 보여준다. 각 시간에 카드 C는 딜러에게 보여지는데, 플레이어는 만약 다음의 조건들 중 하나를 만족하면 카드를 가진다.

- 선수가 어떤 카드도 가져간 적이 없다.
- 플레이어가 가진 카드는 오름차순이며, 현재 카드 C는 플레이어가 가지고 있던 마지막 카드보다 커야 한다.
- 플레이어가 가지고 있던 카드보다 작은 카드를 받았을 때, 후에 받을 각 카드의 번호는 플레이어가 가지고 있는 가장 마지막 카드보다 낮아야 한다.

----

**질문 :**

(1) 중복된 카드 가질 수 있나요?

(2) 9 6 7 6 5 4 3 2 1 나오게 되면 답이 9일까요?



**0 1 2 3 8 (3 or 6)**

---------------------

**역순으로 카드를 짚어야 할 필요**도 있다. 이때를 어떻게 구분하냐.

다음 카드가 자기 카드보다 작다면, 검사를 한다.

검사 : 

(1) 남은 카드들의 

(2) 

-----------

1. input date를 vector로 받는다.

2. index check를 하기 위한 check vector도 만들어놓는다.

3. 
4. 



원래 규칙대로, 자기보다 큰것만 받되, 체크를 한다. 

첫번째 카드를 무엇으로 받냐가 관건이다. 첫번째  카드는 이전 카드가 없기 때문에 뭐든지 받을 수 있기 때문이다. 그렇기 때문에 for문으로 돌리되, 만약 남은 카드의 수(first의 인덱스 ~ end)가 max보다 작다면 굳이 비교할 필요가 없게 된다.

1. 모든 경우의 수를 다 체크할 필요는 없다. 그 기준을 무엇으로 할 것인지. 
   1. 첫번째 카드를 받는 경우 안받는 경우가 달라짐. 왜냐하면 첫번째 카드를 받을 때는 이전 카드가 없기 때문에 받는다고 해서 limit이 정해지지 않는다. 그렇기 때문에 첫번째 카드를 안받을 때의 경우도 생각해야 함.
      예를 들어, 3 1 2 ~ 일때, 3을 안받는게 이득.
   2. stack.top()보다 크면 무조건 넣는가? 
   3. (앞으로 남아있는 숫자들의 평균(min, max의 평균) 보다 작다면  + index가 체크가 안되어있다면) 버린다.
   4. 평균보다 크다면 가진다. 계속 카운트 
   5. 위의 방법 반복하는데, 순서가 어긋난 숫자를 가질때의 index 체크를 한다. 

--------

1. 첫번째 카드에 대해서는 for문으로 돌린다. first를 바꿔가면서.
2. 이제 그 안에서 for문을 또 돌리는데, 이때는 
   1. 정상 : 만약 다음 숫자가 현재 숫자보다 클 때, 다음 숫자의 크기가 평균보다 작아야 좋다. 크면 다음 것들을 담기 힘들어지기 때문에 
   2. 비정상 : 만약 다음 숫자가 현재 숫자보다 작을 때, 다음 숫자의 크기가 평균보다 커야 좋다. 작으면 limit이 낮아지기 때문에 작으면

------------

함수를 만들자.

func : 해당 선택에서의 최대값을 반환하는 함수. (recursion 함수)

해당 선택이란, 현재 인덱스의 값을 넣을지 말지. (넣는 경우와 버리는 경우)

parameter : index(처음엔 0부터 시작되고 다음 함수부를 때 +1씩 됨), limit(처음엔 50000, 만약 역순으로 진행되면 변경됨), stack은 전달하기(매 함수 시작때 copy해서 쓰기..

-----------

dp 1 : ascending order 

dp 2 : 오른쪽에 작은 게 있는지 없는지 

----------

dp1 : 각 index에서 좌측으로 가질 수 있는 최대 오름차순 요소 개수

dp2 : 각 index에서 우측으로 가질 수 있는 최대 내림차순 요소 개수
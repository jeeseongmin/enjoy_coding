# C5. Balloons

파티를 하기 위해 수평라인에 풍선을 n개 설치해야 한다.

풍선에 바람을 넣으면 점점 지름이 커질 것이다. 최대 크기만큼 넣을 수 있다.(반지름이 될때까지)

처음에는 모든 풍선들에 바람이 없고, 따라서 radius 반지름은 0이다. 당신은 x_i+1보다 작은 x_i를 추측해야 한다. (1<=i<n)일 경우에.

우리가 선을 따라 x_1부터 한개 떨어진 곳으로부터 한개씩 풍선을 분다. i번째 풍선은 다음과 같은 조건들을 만족하게 된다.

i번째 풍선은 이미 존재하는 풍선들의 한개와 닿는다.

i번째 풍선의 반지름은 주어진 반지름 r_i

근데, 이미 바람을 불었던 Balloon과 만나게 되면 더 키울 수 없다. 

앞에서부터 하나씩 불어올건데, 불었을 때의 그 크기들이 있을 텐데, 그 순서대로 쭉 출력하면 된다. 

----------------

두 원의 두 점 사이의 거리는 , (x1, y1) (x2, y2)라고 할 때, 다음의 식이 된다.
$$
\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}
$$
모든 원은 이전 원들과의 반지름에 영향을 받는다.

: 그럼 어디까지 체크를 해야할까? 이전? 이전 두개? 

(0,9) (8,1)

루트 (64+64) = 128= 4*32 2+5 2^7



(0,9) (13,x)

두 원의 거리 = 루트 [13의 제곱 + (x-9)제곱] 

두 반지름 = 9 + x 

루트 [169+(x-9)제곱 ] >= 9+x

169 + (x-9)^2 >= (x+9)^2

169 >= 36x

169/36 >= x

답 : 4.6944444 >= x

--> 두 원이 겹칠때에는 두 원이 만나는 지점에서 반지름이 최대가 된다.

------

1. **Brute force**

   최대 1부터 10만까지이기 때문에, n^2보다는 훨씬 작지만, n보다는 큰 시간 복잡도를 통해 구해볼 수 있다.

   ```
   1부터 n개의 원을 만들어 나가는데, 이전 원들의 좌표와 현재 원의 좌표를 계산해서 현재 원이 가질 수 있는 최대 반지름을 구한다.
   검사 : 두 원의 중심점간의 거리 >= 원1의 반지름 + 원2의 반지름
   만약 검사를 만족하지 않는다면 두 원은 겹치는 것이다.
   이때, 잘못하면 이전 원들과 다 검사를 하게될 수도 있는데, 이 조건을 잘 세우면 n의 원을 만들때, n-1개의 원을 만들어보지 않아도 알 수 있다.
   
   * 조건 : 이게 제일 중요함.
   외접 index라고 하면, 모든 원들을 horizontal line과 수직하는 두 선중, 우측 외접선의 x좌표를 의미한다.
   1) 이전 원은 무조건 검사 대상. (외접 index든 뭐든 상관없이 검사 대상이다.)
   2) 이전 원을 제외한 나머지 원들의 우측 외접 index와 현재 원의 이상적인 좌측 외접 x좌표를 비교해서, 
   if(cur_left <= index_right) 라고 한다면 검사해야 한다.왜냐하면 이것은 겹칠 가능성을 의미하기 때문이다. 새로 생길 원의 좌측 x좌표보다 이미 만들어진 원의 우측 외접 x좌표가 더 크다면 겹쳐있을 가능성이 크기 때문에 검사 대상에 들어간다.
   	- 
   
   # 근데 여기서 문제 : 최악의 경우일 때, 매번 1 ~ n-1 까지의 모든 원을 커버할 수 있는 반지름이 나오게 된다면 계속 검사해야 하기 때문에 bad case가 된다. 
   근데 이것을 c++의 map container에 사용해서, 계속 정렬되도록 한다면?
   index_right 순서대로 정렬이 되기 때문에 괜찮을 것 같다.
   : key = index, value = right_index
   그러면 index_right가 큰 쪽의 index부터 cur_left와 비교 후(만약 cur_left보다 크지 않다면) 검사를 하면 되고, 가장 큰 index_right 조차 cur_left보다 크지 않다고 하면, 이전 원만 검사하면 된다.
   
   검사 순서 : 
   main 함수 에서는
   radius[i] = blow(i);
   
   blow 함수에서는
   ( index_right>=cur_left ) 조건을 만족한다면 
   먼저 index_right에서부터 가장 큰 값부터 검사하며 이전 원과의 관계도 만족하는지 확인한다.
   만족한다면 그때의 radius를 계산하면 된다.
   radius : 내 반지름 = 두 점 사이의 거리 - 다른 원의 반지름
   그리고 최종적인 값을 return 한다.
   
   마지막으로 radius들을 출력하는 for문으로 종료한다.
   ```

2. 

----------

```
알고리즘을 좀 더 다듬어보자.

map(init_info)에는 모든 풍선의 정보들이 index(key)를 기준으로 radius(value)가 정렬되어있다.
multimap(sort_info)은 현재 index 이전의 모든 풍선들의 right_x, 즉 horizontal line에 수직인 우측 외접선의 x좌표를 기준으로 index가 정렬되어있다.

for문 : init_info에 있는 좌표들의 순서를 기준으로 반복한다.
	0) 시작점일 경우, sort_info에 right_x와 index를 저장하기만 한다.
	1) 시작점이 아닐 경우, 가장 right_index가 큰 요소부터 비교하기 시작해서, 만약 현재 원의 left_index보다 크다면 겹칠 가능성이 있는 것이므로 검사를 시작한다.
		1-1) 검사 : 일단 겹치는지 확인하기 위해서, 두 원의 중심점간의 거리가 두 반지름의 합보다 작은지를 확인한다. 만약 작다면 확실히 겹치는 것이므로, 현재 원의 반지름을 미지수로 두고, 원의 반지름을 구하는 공식을 통해 원의 반지름을 구한다.
		temp_radius = (pow(cur_x-last_x,2)/(4*last_y));
		그리고 나서는 자신의 이전 원과도 검사를 해서 두 원의 중심점간의 거리가 두 반지름의 합보다 작은지를 확인한다. 작다면 겹치는 것이므로 temp_radius를 이전 원과 만날 때의 반지름으로 둔다.
		그리고 max_radius와 temp_radius를 비교해서 max_radius를 업데이트해준다.
		max_radius가 최종적인 반지름이므로 sort_right에 max_radius와 index를 insert한다.
		그리고 init_info의 radius를 max_radius로 새로이 업데이트한다.
		1-2) 만약 겹치지 않는다면, 다음 right_index를 비교하기 위해 다음 iterator로 넘어간다.
	2) 만약 현재 원의 left_index보다 right_index가 작다면 for문을 탈출한다.
		2-1) 이때, max_radius가 0인 경우라면 모든 right_index가 현재 원의 left_index보다 크지 않다는 것이기 때문에 이전 원의 값을 max_radius로 입력한다. 그리고 여기서 sort_info에서 가장 큰 요소와 비교하지 않아도 되는 이유는, 모든 right_index가 현재 원의 left_index보다 크지 않다는 말 자체가 겹칠 이유가 전혀 없다는 의미이기 때문이다.
		max_radius가 최종적인 반지름이므로 sort_right에 max_radius와 index를 insert한다.
		그리고 init_info의 radius를 max_radius로 새로이 업데이트한다.
	3) 결국 init_info에 담긴 반지름들을 출력하면 된다.

```

---------------

$$
만나는경우 : \sqrt{(x_2-x_1)^2+(y_2-y_1)^2} = r_1+r_2
$$

$$
겹치는 경우 : \sqrt{(x_2-x_1)^2+(y_2-y_1)^2} < r_1+r_2
$$

$$
만나지 않는 경우 : \sqrt{(x_2-x_1)^2+(y_2-y_1)^2} > r_1+r_2
$$

```
제가 생각한 알고리즘은,
1) 두원의 중심을 통해 원이 겹치는지 아닌지를 판단할 수 있다.
2) 기존 원들의 반지름은 픽스되어있다.
3) 기존 원들의 수평선과 수직인 우측 외접선의 x좌표 값(last_right)을 저장해놓는다. 그리고 현재 원의 최대 반지름일 때의 좌측 외접 x좌표(cur_left)를 구해놓는다.
	3-1) last_right가 cur_left보다 같거나 작은 경우는 절대 겹치지 않는다.
	3-2) last_right가 cur_left보다 큰 경우는 겹칠 가능성이 있다.
		3-2-1) 겹치는 경우인지 확인한다.
			- 겹친다면, 이전 원과의 관계도 확인한다.
			- 겹치지 않는다면, temp_radius에 저장해놓는다.
```

1)  last_right <= cur_left 라면 절대 겹치지 않으므로 현재 반지름을 그대로 설정한다.

2) last_right > cur_left라면 겹칠 가능성이 있다. 그것들만 다 검사.
검사할 시에 

Time limit 뜰 가능성 높음.

---------

last_right : 지난 것들의 우측 외접 x좌표

for => pre_right들을 저장해놓은 일종의 list

map : init_info (모든 정보들을 저장해놓은 ) key:index, value: radius

multimap_2 : sort_right /  key : right_x, value: index;

sort_right.begin() -> first  --> 최댓값

input 모두 받고나서



3 10 8 13 

13 10 8 3 

9 

```
for문(init_info ~) {      // 모든 원들의 반지름을 확정하기 위한 for문
	for문(sort_right~)	// 맨처음 last_right값을 비교하는 경우와, pre_right 인 것들중 반지름이 최소가 될 경우를 판단하기 위해서.
		if(sort_right.begin()->first < cur_right) // min = cur_y;
		else {
			// 겹칠 가능성이 있는 것의 min을 구하기 위함.
			if(pre_right > cur_left) {
				 min 값 갱신.
			}
			// 검사할 필요가 없어짐.
			else {
				break;			
			}
		}
	}
	init_info = min;
	sort_right update;
}

printf(init_info->radius);
```



1) last_right <= cur_left라면 절대 겹치지 않으므로 현재 반지름을 그대로 설정.

2)  pre_right > cur_left라면 겹칠 가능성이 있다. 이때에

​	pre_right > cur_left인 것들 중 반지름이 최소가 될 경우만 판단하면 됨



​	여기서 pre_right가 제일 큰것만 검사하지 못하는 이유는, 




$$
t = (x_1-x_2)^2 / (4*y_2) 
$$
## P2. Hospital Construction

#### **문제의 이해 :**

한도시에 n개의 빌딩이 고속도로를 따라 서있다. (빌딩의 개수는 1<=n<=10,000,000) 10의 7승
i번째 빌딩은 고속도로의 x포인트에 서있는데,  고속도로의 길이는 10,000,000,000으로 10의 10승이다.
그리고 g명의 사람들은 i번째 빌딩에 살고있다. 사람들의 수는 1<=g<=10,000으로 10의 4승이다.

이 고속도로를 따라서는 병원이 없다. 따라서 정부는 건물에 사는 사람들을 위해 병원을 지어야 한다. 빌딩은 병원에서 걸을 수 있는 거리이어야 하고, 그 거리는 적어도 1<=k<=2,000,000 이다. 

정부는 병원을 고속도로의 어느 지점에 세우길 원하고, 가능한 많은 사람들이 최소한 걸어다닐 수 있는 거리이내에 병원을 짓고 싶어 한다. 빌딩과 병원이 적어도 limit(k)보다 적거나 같아야 한다.

그렇기 때문에 병원이 어떠한 포인트에 지어졌을 때에, 걸어다닐 수 있는 범위 내에 얼마나 많은 사람들이 있는지 알아내는 프로그램을 짜라.

#### **요구조건 :**

처음 두 숫자는 n과 k인데, 각각 빌딩 숫자(n)와 걸어다닐 수 있는 거리(k)를 의미한다.
그리고 그 이후에 n개의 line이 주어지는데, 각각 g와 x로, 사람의 숫자와 건물이 위치해있는 포인트를 의미한다.

당신의 프로그램은 한 숫자를 출력해야되는데, 병원으로부터 최소거리에 최대한 많이 사는 사람들의 숫자이다.

병원은 빌딩의 꼭대기에 지어진다.

#### 풀이 과정 :

1. 맨처음에 변수들과 값들을 입력받는다.
   n -> buildings (빌딩수)
   k -> limit (최소 거리) 
   double dist_min =0 (최소 거리)
   double dist_max =0 (최대 거리) 
   count_people (임시 인원 카운트)
   max_people (총 카운트)
   g랑 x를 어떻게 입력받을까가 문젠데. highway 길이가 10의 10승까지인데 이걸 다 배열로 만들기는 오바임.
   그렇기 때문에 고민하는데 지금 생각은 그냥 n line을 받기 때문에 빌딩의 갯수는 n개일 것이고, n개의 배열을 만들면 된다.
   그리고 받으면서 x의 길이에 맞춰서 sorting을 바로 진행한다.
   이건 또 어떻게 하냐.... 입력받으면서 배열을 한번 쭉 훑는다. 훑었을 때 x값보다 큰 값이 나오면 그 자리에 x를 넣고, 나머지를 다 뒤로 민다. 그런식으로 정렬하면, 결국 오름차순으로 정렬이 될 것이다. 
   x_i -> building_info[i]\[0]
   g_i -> building_info[i]\[1]
   헷갈릴 수도 있는데 (거리, 인원수) 위치로 세우기로 함. 
2. 그러면 이제 for문안에서 n갯수만큼 돌리고, build_info[i]\[0]에 따라서
   dist_min = building_info[i]\[0] - k (if dist_min<0 -> dist=0;)
   dist_max = building_info[i]\[0] + k (if dist_max>10^10 -> dist=10^10;)
   으로 설정을 해놓는다.
   이때, for문을 n개수만큼 하나 더돌려서, 
   만약에 build_info[j]\[0]이 dist_min과 dist_max 사이에 있다면 count_people에 building_info[j]\[1]을 더해준다.이런식으로 j for문이 끝나면 max_people과 비교해서 count_people>max_people이면 max_people=count_people 아니면 그대로.
   그리고 dist_min과 dist_max를 초기화시켜준다. 



---------------

이게 빌딩들의 두 좌표의 가운데 지점

예를 들어 limit이 3인데, 1과 7사이라고 하면 
그렇기 때문에 두 좌표의 거리가 x1 x2 라고 할 때, x2-x1이 <= limit * 2 까지의 범위라면 그 사이의 모든 값들을 더할 수 있음.
x2-x1이 > limit이면 땡이기 때문에 탈락.

지금 최종 방식은 :

1. 값을 모두 입력받는다. 총 건물 수는 int buildings, 최소 이동거리는 범위가 10의 10승까지이기 때문에 float limit에 저장한다. 
   건물 지점은 float building_point, 건물 인원수는 int building_people 배열에 저장해서 나열한다.
2. 중요한 건, 건물을 입력받을 때에 max_point를 입력받아서 그것보다 이상 찾아볼 필요는 없고, min_point보다 아래를 찾아볼 필요는 없다. 그렇기 때문에 이 두 가지 값을 입력받아서, for문을 두개를 돌린다. 
3. for문을 돌릴 때, building 수만큼만 돌려보면 된다. 왜냐하면 building 수만큼만 배열이 구성되어있을 것이기 때문이다. 그래서 첫 for문에서 한 building이 key_point가 되었다면, 이를 중심으로 두번째 for문에서는 key_point를 포함하는 모든 building들 간의 관계를 파악해서 총 인원이 있는지를 파악하면 된다.

---------------

지금까지 사용한 방법 :

1. sorting 하지 않고, 받은 배열에서 그대로 for문 두개로 검사 -> O(n^2) 예상
2. quick sorting 하고, sorting 된 배열에서 for문 두개로 검사 -> O(n^2) 예상
3. 마지막 방법 :
   (1) 먼저 sorting을 한다.
   (2) 각 포인트별 거리차이를 구해서 배열로 만든다. 
   ex) between[7] = building_point[7] - building_point[6]; 
   (3) 그 거리 차이만큼 배열이 나오게 되면, 연이어진 숫자 중 limit\*2를 넘는 것은 제외하고, 그 지점으로 분배한다.
   인덱스 [0] 부터 더해가면서 다음 인덱스를 더했을 때 6이 넘어가면 바로 두 부분으로 잘라서 함수로 보낸다.
   만약 limit*2를 넘는다면 두 인덱스의 return ; 해버린다.
   만약 더이상 더할 수 없는 최대 수라면, 최대값을 구하는 함수(새로 만들어야됨)에 집어넣어서 최대값을 return 받고 final_최대값과 비교해서 값을 update한다. 그리고나서 dynamic programming 배열이 있는데, 그곳에 값을 저장하고 return 한다.
   만약 

-------------

1. between의 배열들 중 limit*2보다 큰 것 전후로 나눈다.
   그리고 맨처음에 썼던, 배열중에 최댓값이 가장 큰 것을 찾아내는 함수를 사용한다.
2. 그래서 모조리 





------------

0 인덱스는 같이 시작한다. 그리고 만약 현재 인덱스의 배열값이 이전 합보다 크다면 현재 인덱스의 배열값으로 설정한다. 현재 인덱스 배열값보다 이전합+현재 인덱스 배열값이 더 크다면 이전합+현재 인덱스 배열값으로 설정한다.

우리 과제에서는 
c는 between의 합으로 limit*2보다 작거나 같아야 하고, 그럴때마다 c_sum[i] 배열에 c_sum[i-1]+building_people[i]값을 더해야 한다.
for(i=1; i<n; i++) {

​	if(between[i] >= limit*2) {

​		c_sum[i] = building_people[i];

​		c[i] = 0;

​	}

​	else if(between[i] + c[i-1] >= limit*2) {

​		c_sum[i]

​	}

​	else if(between[i] > between[i] + c[i-1]) {

​		

​	}

​	c[i] = (between[i] <= limit\*2)  

}

만약 between[i]의 값이 limit*2보다 크다면, c_sum[i]배열에 building_people[i]값을 그냥 더한다. 
이런식으로 만들게 되면, 



세 가지 경우

(1) 차이값이 limit*2보다 클 때 : 이때는, 그냥 c_sum[i]에 building_people[i]을 집어넣고, c[i]에는 0을 집어넣으면 된다. 왜냐하면 c 배열은 현재 내가 값을 잘 더하고 있는지 

-------------

#### 발표

이 Hospital Construction문제를 풀면서 정의는 다음과 같이 해보았습니다. 
병원까지 걸어다닐 수 있는 walking distance가 limit이라고 할 때에, 각 빌딩의 point-limit과 각 빌딩의 point+limit 범위 내에 있는 모든 빌딩의 사람수가 max일 때를 구하는 것입니다.
제가 가운데 부분에 building_people[i] 라고 적었는데, 포인트와 인원수는 크기 비교하는 것으로 잘못 적었습니다. 
사실 저는 이 문제를 풀다가 time limit에 걸려서 풀지는 못했습니다.
먼저 제가 실패한 문제 해결 방식은 다음과 같습니다.
building들의 point와 building의 people을 point를 기준으로 sorting한 뒤에,
문제 정의에서 말씀드린 limit을 가지고, brute force 방식으로 현재 index를 0부터 백억까지 돌리게 되는데, 현재 index를 기준으로 최소범위, 최대 범위를 지정해서 해당 범위 내에 건물이 있다면 모두 더하고 max 값을 업데이트하는 방식으로 생각했습니다.
사실 지금봐도 가장 bad case인 백억까지 brute force를 한다면 당연히 time limit이 날 것 같은데, 잘못 푼 것 같습니다. 더 효율적인 방식으로 
시간 복잡도는 quick sort에서 이미 정렬되어있는 경우나 역순으로 정렬되어있는 경우가 최악의 경우이기때문에 그 경우 O(n^2)이 된다고 생각했습니다.

공간 복잡도는 일차원 배열을 사용하기 때문에 O(n)이 된다고 생각했습니다.

-------

(퀵소트는 분할정복 방법으로 이루어지는데, 피벗을 기준으로 양쪽을 정렬해가는 방식)
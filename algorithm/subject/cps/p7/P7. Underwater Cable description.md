# P7. Underwater Cable

지진으로 인해 해저망 케이블이 N개의 조각으로 부서져 수면에 순서대로 놓여있다. 그 케이블의 i번째 조각의 길이를 s_i라고 하자.

물속에서 전기용접을 할 수 있는 수중 로봇을 사용하여 모든 조각을 하나로 다시 연결하려는 경우 로봇은 한 번에 케이블의 인접한 두 조각을 다시 연결한다. 

각 접합 후 용접 오페라 도중 고전압 감전으로 인한 결함이 없는지 전체 접합 부분을 확인해야 한다.

전기 용접에 결합하는데 필요한 시간은 방치되어 있지만 결함확인 공정은 결함확인 공정은 s_i + s_i+1의 시간이 걸린다. 

로봇의 전체 조각을 하나로 다시 연결할 수 있는 최소 시간을 찾는 프로그램을 작성해라.

---------

#### Input

Input data는 standard input으로 주어진다. 첫번째 줄은 positive integer N을 가지고, 3이상 500이하의 값을 가진다.

그리고 그것은 조각의 개수를 나타낸다. 다음으로 나오는 줄들은 N개의 양수들이다.

각각은 blank로 분리되어있고, 조각의 길이를 나타낸다. piece 1부터 piece N까지 순서대로 나타나있다. piece 의 길이는 10000을 넘지 않는다.

--------

#### Output

결과를 출력해라. 

-------

#### 풀이 :

가장 그 라인에서 큰 수를 기준으로 구간을 나눈다. (recursion)

stack을 사용해서 3개를 계산할 때, 

만약 항목의 개수 (end-start+1) 가 2라면 sum += 두 항목의 합을 더한다.

만약 항목의 개수 (end-start+1) 가 3이라면 모든 항목의 합을 더한 뒤에, 가운데 항목과 양끝 좌우 중에 더 작은 항목을 더한다. 

만약 항목의 개수 (end-start+1) 가 4라면 sum += 네 항목의 합*2 을 해준 뒤에, 4개의 항목을 하나로 줄인다.

만약 항목의 개수 (end-start+1) 가 5이라면 합이 가장 작은 두 항목을 더해준 뒤, 네 항목의 합으로 진행한다.

----

0. 모든 항목을 data라는 이름의 vector로 받는다.

1. data의 복사본인 cdata를 함수에 집어넣는다. 

2. 함수의 parameter는 (cdata, start, end)로, start와 end 까지의 숫자들 중 최소 시간으로 여러 조각들을 하나의 조각으로 만드는 것이다.

3. combine 함수의 구성은 다음과 같다.

   ```
   int leng = end-start+1;
   if(leng > 5) {
   	// 가장 큰 숫자를 기준으로 양쪽을 나누어 현재 함수에 다시 넣는다. 
   	int left = combine(cdata, start, mid-1);
   	int right = combine(cdata, mid+1, end);
   	// left + max + right값을 모두 더하고 2배 곱한 값을 sum에 더한 뒤,
   	// left, right 값 중 더 큰 값을 sum에서 뺀다.
   }
   else if(leng == 5) {
   	// 가장 합이 작은 이어지는 두 숫자를 더하고,
   	// start~end 범위의 값들을 모두 더한 뒤 2배 곱한 값을 sum에 더한다.
   }
   else if(leng == 4) {
   	// start~end 범위의 값들을 모두 더한 뒤 2배 곱한 값을 sum에 더한다.
   }
   else if(leng == 3) {
   	// start~end 범위의 값들을 모두 더하고 2배 곱한 값을 sum에 더한 뒤,
   	// start, end값중 더 큰 값을 sum에서 뺀다.
   }
   else if(leng == 2) {
   	// 그냥 sum에 두 값을 더한다.
   }
   
   ```

   -----

4개 짜리 에서 가운데가 가장 작을 때에는 4항목 * 2가 최소이다.

그게 아니면 

--------

1. start ~ end 범위에서 가장 큰 수를 기준으로 양 쪽을 나눈다.
2. 계속해서 나누는데, 단 조건이 개수가 4개 이상이어야 한다.
   1. 4개 일 때 가운데 두 수의 합이 양 사이드와의 합보다 작다면 모든 합의 두배가 최소값이다.
3. 만약에, 최대값이 맨 오른쪽 혹은 맨 왼쪽에 있을 수 없다.
   1. 양 사이드에 최대값이 존재한다면, 길이가 4보다 클 때 모든 index에서의 합 중에 가장 합이 작은 두 값을 더해서 다시 비교한다.그래도 최대값이 양사이드에 있다면 계속 반복한다.




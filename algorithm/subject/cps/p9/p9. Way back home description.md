# P9. Way back home

여러 명이 각각의 위치와 속도를 가지고 있다. 같은 위치가 되는 사람들은 한 그룹이 되며 더 낮은 속도를 가지게 된다. 이때, 마지막에 최소 몇개의 그룹이 남게 될까?

--------

현재 위치와 t초 후에 위치를 모두 받아놓는다.

t초 후의 위치는 오름차순으로 되어있어야 정상이다. (아무도 안겹치는 경우) 검사하고 answer++;

그런데 위치가 같아지거나 위치가 더 작은 경우에는 다음 요소와 한 그룹이 되면 그룹화하며 t초후의 위치를 재정비한다.

----

따라잡으면 따라잡힌 것의 속도가 되고, 따라잡힌 것의 목표대로 된다.

각 인덱스가 도달할 수 있는 최대 위치가 있다. 

current : 0 1 2 3 6

arrive :   3 7 11 9 9

앞에꺼보다 낮은 위치가 등장하게 된다면, 

index 체인지가 발생한다.  

--------------------

기본 : 1 ~ time 까지 한번씩 증가시키면서 합쳐질때마다 삭제를 진행한다. 그리고 총 갯수를 확인한다. 

변형 : 흡수를 시킨다는 개념. 원래 이상적인 위치(자기 위치 + 시간 x 속도)를 다 저장해놓는다. 그리고, 위치를 key로 정렬하고, value로 index를 가진다. 
왜 흡수 개념이냐면, 아무리 위치가 높다 할지라도, 만났을 때에는 더 작은 속도를 가진 그룹으로 속해지기 때문에다. 흡수된 항목은 check표시를 1로 해놓는다. check가 1이 되었다는 의미는 사라졌기 때문에 더이상 고려하지 않는다는 의미. 

key value
3     0
7     1
9     3
9     6
11   2

이제 key값을 가져오게 되면, 해당 key값 이전의 index들과만 비교한다.  그 이유는, 작은 순서대로 오름차순이기 때문에 이보다 저 작은 것이 이후에 나올 수가 없다는 의미. 그렇기 때문에 이전 값들만 비교한다.

key기준 이전 index들중에서 비교하는 방법은 다음과 같다.
여러가지 value들이 있을 텐데, 그 중 제일 처음 만나게 되는 항목을 흡수한다.
만약 최종 위치 value보다 작다면, x1 + Mv1 = x2 + Mv2라는 공식을 가지고, M값들의 minimum인 순간의 index를 찾아내어 priority queue에 집어넣는다. M을 key로 index를 value로.

-------------------

위치가 더 큰것들에 한해서 M값을 구한 뒤에 이를 또 priority queue에 집어넣는다. 왜냐하면 항목을 만날 때마다 합쳐질 텐데, 빨리 만나는 순서대로 합쳐지기 때문이다.
만약 먼저 꺼가 합쳐지게 되면 check를 해두면 되고, 현재 항목의 최대 위치를 update한다. 그 다음 index의 최대 위치가 현재 항목의 최대 위치보다 크다면 check 하고, 현재 항목의 최대 위치를 다시 update한다.

그리고 check항목이 0인 것의 개수를 세면 된다.

----
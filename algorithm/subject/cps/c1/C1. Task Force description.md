C1. Task Force
: 해병대에서 병사들이 팀을 꾸리는 것.
기존 있던 사병중에 팀을 꾸리는데, 팀을 꾸릴 때 규칙은, 팀 안에서는 모든 병사가 k명의 친한 친구가 있어야 한다. 병사간의 친구관계가 정보로 주어진다. 이 조건을 만족하면서 가장 크기가 크게 팀을 꾸렸을 때, 그 크기가 얼마인지 맞추는 문제이다.

DFS(Depth-First- Search)와 제일 유사 : 깊게 탐색. (BFS 너비 우선 탐색 과는 반대)

먼저 중요한 것 :

1. 친구 관계가 나오기 때문에 이것을 undirected Graph로 생각하면 좋을 것 같다. 그래서 이것을 먼저 인접 리스트로 배열을 만들어놓으면 좋을 것 같다.

예를 들어서 
5 2 6
1 2
3 2
3 4
4 5
5 2
2 4

이라고 했을 때 맨 첫줄은, n, k, f를 의미하는데, n은 병사들의 총 명수, k는 최소한 한 그룹에 몇명의 친구가 있어야 하는지, f는 친구 관계의 갯수이다.

필요한 변수 목록 : 

- n(병사 총 명수) -> int marine : 범위는 1<= n <= 2000
- k(최소 친구 관계) -> int min_relation : 범위는 1<= k <= n
- f(총 친구 관계) -> int total_relation : 범위는 1<= f <= n(n-1)/2
- int max_relation = 0; # 최대값이 갱신될때마다 변경된다. 그리고 결국 output을 의미한다.
- int arr_relation[?]\[?] : 관건은 모든 병사들의 숫자대로 인접 리스트를 만들어야 할지, 아니면 딱 필요한 만큼만 만들어야 할지 생각을 해야한다. 근데 과연 두개를 나누는게 의미가 있을까? Space complexity를 사용하면 어차피 2차원 배열로 n^2이 되는게 아닐까? 하는 의문도 든다.

- int cur_relation[n] : max_relation을 따질 때에, 추가되는 항목을 
- int node[?] : 모든 노드들을 배열로 포함한다. 

input 받는 방법 : 

- 파일이라고 생각하고, 주어진 라인을 쭉 받으면 되겠지?

알고리즘 : 

- 인접 리스트가 구성이 되었다면, 유효한 맨 위부터 구성해간다. 예를 들어, 인접 리스트의 5 2 6
  1 2
  3 2
  3 4
  4 5
  5 2
  2 4
  이 있다고 치면,
  인접 리스트는
  1 2
  2 1 3 4 5
  3 2 4
  4 2 3 5
  5 2 4
  라고 구성이 될 텐데, 이때 위에부터 계산을 하면서 max_relation을 계산하는 것이다.
  먼저 1이라는 노드부터 시작하는데, 1의 인접 리스트에는 2밖에 없으니까 넘어가게 된다.
  그리고 나서는 다음 노드(2)부터 시작한다. 
  2는 4,5 두개가 있기 때문에 포함되며 먼저 {2, }가 담기고, 4가 정상적으로 2개의 관계를 가지는지 확인한다. 그리고 포함된다면, {2,4,} 가 되며, 다시 2의 노드로 돌아와 5를 검사한다. 
  이때, 2개의 관계를 가지는지 확인하는 함수를 만든다. 또한 확인되었다면, 마치 recursion처럼 2의 노드의 child들을 검사한다. 
  여기서 함수가 포인트이다. adjency list가 만들어졌다고 했을 때, 첫번째 노드값부터 함수에 집어넣기 시작한다. 이때, arr[i]\[0]값을 확인하는데, arr[i]\[0]값이 0이라고 하면 항목이 없으므로 패스. 0이 아닌 1이라고 할 때만 check 함수에 집어넣기 시작한다.
  check 함수 구성 : adj
  1. 해당 노드 값의 adj_list의 child 항목이 2개 이상인지 체크한다. 아니라면 다음 노드값으로 넘어간다.
  2. 만약 2개 이상이라면, 그 각 노드 또한 check 함수에 집어넣는다. 그러면서 해당 노드의 항목은 check_list에 추가한다. 이 check_list는 검사하고 있는 항목인지 판단하기 위해서 만들어진다. 
     ex) check(4), check(5) --> 이 또한 child가 2개 이상인지 체크하고, check_list에 포함되어있는지를 확인한 뒤에 아니라면 check_list에 값을 올린 뒤, child들을 또 check 함수로 보낸다.
     근데 이 check 함수는 0 혹은 1을 return 하게 되는데, upload = 0으로 시작해서 
     upload += check(4), upload += check(5)가 되는데, upload가 0이면 올리는데에 이상이 없다고 판단해서 node를 max_list에 올린다.
     check(4)에서는 또 자신의 인접 리스트 child 항목들을 검사하고, 이상이 없다면 node = 0 을 return 하게 된다.
     이런식으로 check(2)는 child 항목들 또한 2개의 관계를 가지는지 검사하고, 계속계속 2개 이상의 관계를 가지는 검사하여 포함될지의 여부를 판단한다.
     만약 check(4)는 정상적으로 0을 return 하면 대기 list에 올라가고, check(5)는 1을 return 했다하면 대기 list에 올라가지 않을텐데, 그렇게 되면 대기 list가 초기화된다.
     check(2)에서 upload가 정상적으로 0을 return 받을 때 대기 list의 항목들이 모두 max_list에 올라가게 된다. 
  3. 이런 방식으로 첫노드부터 끝노드까지 진행하면서 max_list들을 계속해서 갱신해나가면 된다.





제가 생각한 알고리즘은

일단 처음에 input을 adjency matrix로 받습니다.

그리고나서 최소 관계 횟수만큼 가지고 있지 않은 node들을 모두 삭제해서 adjency matrix로 만듭니다.

여기서 이제 남아있는 노드들은 최소 관계 횟수보다는 많은 노드들이 남아있습니다.

그렇게 되면, 그 노드들을 기준으로 max값을 체크합니다.

체크하는 방법은

두개의 for문 안에서 현재 노드가 꼭 포함이 된다고 생각을 하고, child가 1인 경우에 그 모든 노드들의 child들로 들어가는 형식으로 생각했어요. child와 node들을 모두 일차원 배열에 저장하고, 마지막에 그 배열의 1인 요소들만 세서 최종 max값과 비교해서 더 크면 교체하는 방식?

ex)

5 2 6
1 2
3 2
3 4
4 5
5 2
2 4

이라고 하면

0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 1 1 1
0 0 1 0 1 0
0 0 1 1 0 1
0 0 1 0 1 0

adjency maxtrix가 이렇게 되고, 

1 2

2 3 4 5

3 2 4

4 2 3 5

5 2 4

가 되는데,

1 2 가 없어지겠죠? 그러면

2 3 4 5

3 2 4

4 2 3 5

5 2 4

만 남게 되는데, 이때부터 체크하기 시작합니다.







1. 먼저 1부터 시작. 만약 mark가 되어있으면 건너 뛴다.
2. mark가 안되어있다면 해당 노드의 child가 조건보다 적은지 판단. 적다면 count를 줄이고, 해당 노드의 arr[node]\[child] 뿐 아니라 arr[child]\[node] 들의 count도 모두 줄이며 0으로 만든다.
3. DFS로 깊숙이 끝까지 들어가면서 검사를 한다.
   이때, 만약 
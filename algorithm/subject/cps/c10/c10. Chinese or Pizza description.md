# C10. Chinese or Pizza

당신은 두 레스토랑 브랜드의 프랜차이저이다. 하나는 피자집이고, 하나는 중국집이다. 당신은 도시에서 N개의 빌딩을 소유하고 있다.

당신은 당신 소유의 모든 빌딩 중 브랜드 한개의 식당을 오픈하고 싶다. 이익을 최대화하기 위해서 당신은 만약 같은 브랜드의 다른 식당이 5마일 이내에 있다면 식당을 열 수 없다.

N개의 빌딩 위치가 좌표평면으로 주어졌을 때에 다양한 레스토랑과 빌딩의 조합이 존재할 수 있다.

당신은 N개의 빌딩 위치를 입력받고 최소한 가능한 조합으로 열 수 있는 식당의 갯수가 몇개인지 찾아내야 한다.

----------

반대로, 최대한으로 많은 음식점을 찾는 것도 방법이라고 생각한다.

모두 입력받고, A부터 5간격 이외의 지점들에 체크를 한다. 

그리고 체크한 부분들의 합, 체크하지 않은 부분들의 합에 대해서 더 작은 것이 답.

--------

다이나믹 프로그래밍처럼 상태를 저장해놓고 풀면 좋을 것 같다. 

------

주변의 것들과 거리가 5보다 큰 것들은 어떤 것이든 들어갈 수 있음.

test(1, check) : 1에 식당을 짓고 

test(2, check) : 1에 식당을 안짓고 

test는 check 상태를 통해 지어지는 식당의 최솟값을 반환.

최솟값과 num이 같다면 answer = 0이 된다.

--------

점 사이의 거리가 5보다 작거나 같다면 무조건 다른 음식점이 들어와야함.

점 사이의 거리가 5보다 크면 같은 음식점이 들어올 수도 있음. + 다른 음식점이 들어올 수도 있음.

그렇기 때문에 점 사이의 거리가 5보다 큰 그룹으로 나눈다.

1. 인접 리스트를 만든다.
   이전의 인덱스들 중에 x좌표 사이의 거리가 5보다 작은 것들 중에 두 점 사이의 거리가 5보다 작은지 체크를 모두 해서 정리.
2. 왼쪽 인덱스부터 시작해서 x좌표 간의 거리가 5보다 큰 경우 이전 인덱스까지 묶는다. (start, mid / mid, end)
3. 각 그룹들은 서로 붙어있을 가능성이 높은 요소들을 포함. 

---------

1. 정렬한다.
2. 함수 : 해당 요소 이후부터 끝항목까지의 요소들과 비교를 하는데, 먼저 x좌표간의 거리가 5보다 크거나 check가 되어있으면, 다음 요소로 넘어간다. (이때 check 벡터는 전역 벡터)
   x좌표간의 거리가 5보다 작고, check가 안되어있으면 두 점 사이의 거리를 확인하고 사이의 거리가 5보다 작다면 인접 리스트에 추가하고, q에 넣는다.
   그러면 한바퀴를 돌았을 때 q에는, 첫 요소와의 거리가 5인 요소들이 있을 것이다.
   그 모든 요소들에 대해서 함수에 똑같이 넣는다.
3. 마치고나면 인접리스트들이 형성이 되는데, 이 인접리스트가 의미하는 바는 서로 요소들간의 영향을 주는 것.
   인접 리스트의 size가 없는 부분들은 어느 곳과도 영향을 주지 않음을 의미하기 때문에 최소값이 0이 된다.
4. 이 인접리스트들로 분리된 여러개의 그래프가 생성이 되는데, 이때 각 그래프에서 구할 수 있는 최소값들의 합이 답이된다.
5. 인접리스트별 그래프는 BFS 컬러링을 통해 확인한다.
   조건 1) 자신과 인접 리스트의 요소들과는 컬러링이 달라야 한다. 그렇기 때문에 먼저 자신의 색(1)을 칠하고, 자신의 인접 리스트 요소 모두를 que에 집어넣으면서 다른 색(2)으로 칠한다. que에서 하나씩 빼면서 만약 색이 3인 경우에는 그냥 pop한다. que의 요소의 색과 인접리스트 요소의 색이 다른지를 확인한다. 만약 0이면 자신의 반대 색으로 바꾸지만, 자신의 같은 색이면 3으로 변경한다.

------------

1 2 3

2 1 4

3 1 4

4 2 3

홀 수 depth랑 짝수 depth들의 노드 갯수 중 작은 애들의 갯수를 반환한다. 